import{e as t}from"./_/8a70a997.js";import e from"./utils.js";import"@noble/hashes/crypto";var s={};var o=s&&s.__createBinding||(Object.create?function(t,e,s,o){void 0===o&&(o=s);Object.defineProperty(t,o,{enumerable:true,get:function(){return e[s]}})}:function(t,e,s,o){void 0===o&&(o=s);t[o]=e[s]});var n=s&&s.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:true,value:e})}:function(t,e){t.default=e});var i=s&&s.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var s in t)"default"!==s&&Object.prototype.hasOwnProperty.call(t,s)&&o(e,t,s);n(e,t);return e};Object.defineProperty(s,"__esModule",{value:true});s.shake256=s.shake128=s.keccak_512=s.keccak_384=s.keccak_256=s.keccak_224=s.sha3_512=s.sha3_384=s.sha3_256=s.sha3_224=s.Keccak=s.keccakP=void 0;const r=i(t);const c=e;const[a,h,u]=[[],[],[]];const k=BigInt(0);const f=BigInt(1);const l=BigInt(2);const d=BigInt(7);const p=BigInt(256);const _=BigInt(113);for(let t=0,e=f,s=1,o=0;t<24;t++){[s,o]=[o,(2*s+3*o)%5];a.push(2*(5*o+s));h.push((t+1)*(t+2)/2%64);let n=k;for(let t=0;t<7;t++){e=(e<<f^(e>>d)*_)%p;e&l&&(n^=f<<(f<<BigInt(t))-f)}u.push(n)}const[w,b]=r.split(u,true);const rotlH=(t,e,s)=>s>32?r.rotlBH(t,e,s):r.rotlSH(t,e,s);const rotlL=(t,e,s)=>s>32?r.rotlBL(t,e,s):r.rotlSL(t,e,s);function keccakP(t,e=24){const s=new Uint32Array(10);for(let o=24-e;o<24;o++){for(let e=0;e<10;e++)s[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const o=(e+8)%10;const n=(e+2)%10;const i=s[n];const r=s[n+1];const c=rotlH(i,r,1)^s[o];const a=rotlL(i,r,1)^s[o+1];for(let s=0;s<50;s+=10){t[e+s]^=c;t[e+s+1]^=a}}let e=t[2];let n=t[3];for(let s=0;s<24;s++){const o=h[s];const i=rotlH(e,n,o);const r=rotlL(e,n,o);const c=a[s];e=t[c];n=t[c+1];t[c]=i;t[c+1]=r}for(let e=0;e<50;e+=10){for(let o=0;o<10;o++)s[o]=t[e+o];for(let o=0;o<10;o++)t[e+o]^=~s[(o+2)%10]&s[(o+4)%10]}t[0]^=w[o];t[1]^=b[o]}s.fill(0)}s.keccakP=keccakP;class Keccak extends c.Hash{constructor(t,e,s,o=false,n=24){super();this.blockLen=t;this.suffix=e;this.outputLen=s;this.enableXOF=o;this.rounds=n;this.pos=0;this.posOut=0;this.finished=false;this.destroyed=false;(0,c.assertNumber)(s);if(0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200);this.state32=(0,c.u32)(this.state)}keccak(){keccakP(this.state32,this.rounds);this.posOut=0;this.pos=0}update(t){if(this.destroyed)throw new Error("instance is destroyed");if(this.finished)throw new Error("digest() was already called");const{blockLen:e,state:s}=this;t=(0,c.toBytes)(t);const o=t.length;for(let n=0;n<o;){const i=Math.min(e-this.pos,o-n);for(let e=0;e<i;e++)s[this.pos++]^=t[n++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=true;const{state:t,suffix:e,pos:s,blockLen:o}=this;t[s]^=e;0!==(128&e)&&s===o-1&&this.keccak();t[o-1]^=128;this.keccak()}writeInto(t){if(this.destroyed)throw new Error("instance is destroyed");if(!(t instanceof Uint8Array))throw new Error("Keccak: invalid output buffer");this.finish();for(let e=0,s=t.length;e<s;){this.posOut>=this.blockLen&&this.keccak();const o=Math.min(this.blockLen-this.posOut,s-e);t.set(this.state.subarray(this.posOut,this.posOut+o),e);this.posOut+=o;e+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){(0,c.assertNumber)(t);return this.xofInto(new Uint8Array(t))}digestInto(t){if(t.length<this.outputLen)throw new Error("Keccak: invalid output buffer");if(this.finished)throw new Error("digest() was already called");this.finish();this.writeInto(t);this.destroy();return t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=true;this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:s,outputLen:o,rounds:n,enableXOF:i}=this;t||(t=new Keccak(e,s,o,i,n));t.state32.set(this.state32);t.pos=this.pos;t.posOut=this.posOut;t.finished=this.finished;t.rounds=n;t.suffix=s;t.outputLen=o;t.enableXOF=i;t.destroyed=this.destroyed;return t}}s.Keccak=Keccak;const gen=(t,e,s)=>(0,c.wrapConstructor)((()=>new Keccak(e,t,s)));s.sha3_224=gen(6,144,28);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */s.sha3_256=gen(6,136,32);s.sha3_384=gen(6,104,48);s.sha3_512=gen(6,72,64);s.keccak_224=gen(1,144,28);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */s.keccak_256=gen(1,136,32);s.keccak_384=gen(1,104,48);s.keccak_512=gen(1,72,64);const genShake=(t,e,s)=>(0,c.wrapConstructorWithOpts)(((o={})=>new Keccak(e,t,void 0!==o.dkLen?o.dkLen:s,true)));s.shake128=genShake(31,168,16);s.shake256=genShake(31,136,32);const y=s.__esModule,O=s.shake256,g=s.shake128,L=s.keccak_512,I=s.keccak_384,v=s.keccak_256,m=s.keccak_224,B=s.sha3_512,K=s.sha3_384,P=s.sha3_256,x=s.sha3_224;const j=s.Keccak,E=s.keccakP;export{j as Keccak,y as __esModule,s as default,E as keccakP,m as keccak_224,v as keccak_256,I as keccak_384,L as keccak_512,x as sha3_224,P as sha3_256,K as sha3_384,B as sha3_512,g as shake128,O as shake256};

