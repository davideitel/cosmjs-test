import{e,a as r,b as t}from"../_/68b237d1.js";import*as n from"@cosmjs/math";import*as o from"@cosmjs/encoding";import{e as u,a as i,b as s,c as a}from"../_/990bea47.js";import*as c from"@cosmjs/crypto";import d from"./signdoc.js";import"@cosmjs/utils";var b="default"in n?n.default:n;var y={};Object.defineProperty(y,"__esModule",{value:true});y.addCoins=y.parseCoins=y.coins=y.coin=void 0;const l=b;function coin$1(e,r){let t;if("number"===typeof e)try{t=new l.Uint53(e).toString()}catch(e){throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.")}else{if(!e.match(/^[0-9]+$/))throw new Error("Invalid unsigned integer string format");t=e.replace(/^0*/,"")||"0"}return{amount:t,denom:r}}y.coin=coin$1;function coins$1(e,r){return[coin$1(e,r)]}y.coins=coins$1;function parseCoins$1(e){return e.replace(/\s/g,"").split(",").filter(Boolean).map((e=>{const r=e.match(/^([0-9]+)([a-zA-Z]+)/);if(!r)throw new Error("Got an invalid coin string");return{amount:l.Uint64.fromString(r[1]).toString(),denom:r[2]}}))}y.parseCoins=parseCoins$1;function addCoins$1(e,r){if(e.denom!==r.denom)throw new Error("Trying to add two coins with different denoms");return{amount:l.Decimal.fromAtomics(e.amount,0).plus(l.Decimal.fromAtomics(r.amount,0)).atomics,denom:e.denom}}y.addCoins=addCoins$1;var p="default"in o?o.default:o;var k="default"in n?n.default:n;var f={};Object.defineProperty(f,"__esModule",{value:true});f.createMultisigThresholdPubkey=f.compareArrays=void 0;const m=p;const g=k;const P=e;function compareArrays(e,r){const t=(0,m.toHex)(e);const n=(0,m.toHex)(r);return t===n?0:t<n?-1:1}f.compareArrays=compareArrays;function createMultisigThresholdPubkey$1(e,r,t=false){const n=new g.Uint53(r);if(n.toNumber()>e.length)throw new Error(`Threshold k = ${n.toNumber()} exceeds number of keys n = ${e.length}`);const o=t?e:Array.from(e).sort(((e,r)=>{const t=(0,P.pubkeyToRawAddress)(e);const n=(0,P.pubkeyToRawAddress)(r);return compareArrays(t,n)}));return{type:"tendermint/PubKeyMultisigThreshold",value:{threshold:n.toString(),pubkeys:o}}}f.createMultisigThresholdPubkey=createMultisigThresholdPubkey$1;var S="default"in c?c.default:c;var h="default"in o?o.default:o;var T={};Object.defineProperty(T,"__esModule",{value:true});T.Secp256k1Wallet=void 0;const w=S;const A=h;const j=e;const v=u;const O=d;class Secp256k1Wallet$1{constructor(e,r,t){this.privkey=e;this.pubkey=r;this.prefix=t}
/**
   * Creates a Secp256k1Wallet from the given private key
   *
   * @param privkey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
   */static async fromKey(e,r="cosmos"){const t=(await w.Secp256k1.makeKeypair(e)).pubkey;return new Secp256k1Wallet$1(e,w.Secp256k1.compressPubkey(t),r)}get address(){return(0,A.toBech32)(this.prefix,(0,j.rawSecp256k1PubkeyToRawAddress)(this.pubkey))}async getAccounts(){return[{algo:"secp256k1",address:this.address,pubkey:this.pubkey}]}async signAmino(e,r){if(e!==this.address)throw new Error(`Address ${e} not found in wallet`);const t=new w.Sha256((0,O.serializeSignDoc)(r)).digest();const n=await w.Secp256k1.createSignature(t,this.privkey);const o=new Uint8Array([...n.r(32),...n.s(32)]);return{signed:r,signature:(0,v.encodeSecp256k1Signature)(this.pubkey,o)}}}T.Secp256k1Wallet=Secp256k1Wallet$1;var x={};Object.defineProperty(x,"__esModule",{value:true});x.makeStdTx=x.isStdTx=void 0;function isStdTx$1(e){const{memo:r,msg:t,fee:n,signatures:o}=e;return"string"===typeof r&&Array.isArray(t)&&"object"===typeof n&&Array.isArray(o)}x.isStdTx=isStdTx$1;function makeStdTx$1(e,r){return{msg:e.msgs,fee:e.fee,memo:e.memo,signatures:Array.isArray(r)?r:[r]}}x.makeStdTx=makeStdTx$1;var C={};Object.defineProperty(C,"__esModule",{value:true});C.executeKdf=C.makeStdTx=C.isStdTx=C.serializeSignDoc=C.makeSignDoc=C.encodeSecp256k1Signature=C.decodeSignature=C.Secp256k1Wallet=C.Secp256k1HdWallet=C.extractKdfConfiguration=C.pubkeyType=C.isSinglePubkey=C.isSecp256k1Pubkey=C.isMultisigThresholdPubkey=C.isEd25519Pubkey=C.makeCosmoshubPath=C.createMultisigThresholdPubkey=C.encodeSecp256k1Pubkey=C.encodeBech32Pubkey=C.encodeAminoPubkey=C.decodeBech32Pubkey=C.decodeAminoPubkey=C.parseCoins=C.coins=C.coin=C.addCoins=C.rawSecp256k1PubkeyToRawAddress=C.rawEd25519PubkeyToRawAddress=C.pubkeyToRawAddress=C.pubkeyToAddress=void 0;var $=e;Object.defineProperty(C,"pubkeyToAddress",{enumerable:true,get:function(){return $.pubkeyToAddress}});Object.defineProperty(C,"pubkeyToRawAddress",{enumerable:true,get:function(){return $.pubkeyToRawAddress}});Object.defineProperty(C,"rawEd25519PubkeyToRawAddress",{enumerable:true,get:function(){return $.rawEd25519PubkeyToRawAddress}});Object.defineProperty(C,"rawSecp256k1PubkeyToRawAddress",{enumerable:true,get:function(){return $.rawSecp256k1PubkeyToRawAddress}});var M=y;Object.defineProperty(C,"addCoins",{enumerable:true,get:function(){return M.addCoins}});Object.defineProperty(C,"coin",{enumerable:true,get:function(){return M.coin}});Object.defineProperty(C,"coins",{enumerable:true,get:function(){return M.coins}});Object.defineProperty(C,"parseCoins",{enumerable:true,get:function(){return M.parseCoins}});var R=r;Object.defineProperty(C,"decodeAminoPubkey",{enumerable:true,get:function(){return R.decodeAminoPubkey}});Object.defineProperty(C,"decodeBech32Pubkey",{enumerable:true,get:function(){return R.decodeBech32Pubkey}});Object.defineProperty(C,"encodeAminoPubkey",{enumerable:true,get:function(){return R.encodeAminoPubkey}});Object.defineProperty(C,"encodeBech32Pubkey",{enumerable:true,get:function(){return R.encodeBech32Pubkey}});Object.defineProperty(C,"encodeSecp256k1Pubkey",{enumerable:true,get:function(){return R.encodeSecp256k1Pubkey}});var E=f;Object.defineProperty(C,"createMultisigThresholdPubkey",{enumerable:true,get:function(){return E.createMultisigThresholdPubkey}});var _=i;Object.defineProperty(C,"makeCosmoshubPath",{enumerable:true,get:function(){return _.makeCosmoshubPath}});var W=t;Object.defineProperty(C,"isEd25519Pubkey",{enumerable:true,get:function(){return W.isEd25519Pubkey}});Object.defineProperty(C,"isMultisigThresholdPubkey",{enumerable:true,get:function(){return W.isMultisigThresholdPubkey}});Object.defineProperty(C,"isSecp256k1Pubkey",{enumerable:true,get:function(){return W.isSecp256k1Pubkey}});Object.defineProperty(C,"isSinglePubkey",{enumerable:true,get:function(){return W.isSinglePubkey}});Object.defineProperty(C,"pubkeyType",{enumerable:true,get:function(){return W.pubkeyType}});var D=s;Object.defineProperty(C,"extractKdfConfiguration",{enumerable:true,get:function(){return D.extractKdfConfiguration}});Object.defineProperty(C,"Secp256k1HdWallet",{enumerable:true,get:function(){return D.Secp256k1HdWallet}});var K=T;Object.defineProperty(C,"Secp256k1Wallet",{enumerable:true,get:function(){return K.Secp256k1Wallet}});var B=u;Object.defineProperty(C,"decodeSignature",{enumerable:true,get:function(){return B.decodeSignature}});Object.defineProperty(C,"encodeSecp256k1Signature",{enumerable:true,get:function(){return B.encodeSecp256k1Signature}});var z=d;Object.defineProperty(C,"makeSignDoc",{enumerable:true,get:function(){return z.makeSignDoc}});Object.defineProperty(C,"serializeSignDoc",{enumerable:true,get:function(){return z.serializeSignDoc}});var H=x;Object.defineProperty(C,"isStdTx",{enumerable:true,get:function(){return H.isStdTx}});Object.defineProperty(C,"makeStdTx",{enumerable:true,get:function(){return H.makeStdTx}});var U=a;Object.defineProperty(C,"executeKdf",{enumerable:true,get:function(){return U.executeKdf}});const G=C.__esModule,N=C.executeKdf,I=C.makeStdTx,J=C.isStdTx,Z=C.serializeSignDoc,q=C.makeSignDoc,F=C.encodeSecp256k1Signature,L=C.decodeSignature,Q=C.Secp256k1Wallet,V=C.Secp256k1HdWallet,X=C.extractKdfConfiguration,Y=C.pubkeyType,ee=C.isSinglePubkey,re=C.isSecp256k1Pubkey,te=C.isMultisigThresholdPubkey,ne=C.isEd25519Pubkey,oe=C.makeCosmoshubPath,ue=C.createMultisigThresholdPubkey,ie=C.encodeSecp256k1Pubkey,se=C.encodeBech32Pubkey,ae=C.encodeAminoPubkey,ce=C.decodeBech32Pubkey,de=C.decodeAminoPubkey,be=C.parseCoins,ye=C.coins,le=C.coin,pe=C.addCoins,ke=C.rawSecp256k1PubkeyToRawAddress,fe=C.rawEd25519PubkeyToRawAddress,me=C.pubkeyToRawAddress,ge=C.pubkeyToAddress;export{V as Secp256k1HdWallet,Q as Secp256k1Wallet,G as __esModule,pe as addCoins,le as coin,ye as coins,ue as createMultisigThresholdPubkey,de as decodeAminoPubkey,ce as decodeBech32Pubkey,L as decodeSignature,C as default,ae as encodeAminoPubkey,se as encodeBech32Pubkey,ie as encodeSecp256k1Pubkey,F as encodeSecp256k1Signature,N as executeKdf,X as extractKdfConfiguration,ne as isEd25519Pubkey,te as isMultisigThresholdPubkey,re as isSecp256k1Pubkey,ee as isSinglePubkey,J as isStdTx,oe as makeCosmoshubPath,q as makeSignDoc,I as makeStdTx,be as parseCoins,ge as pubkeyToAddress,me as pubkeyToRawAddress,Y as pubkeyType,fe as rawEd25519PubkeyToRawAddress,ke as rawSecp256k1PubkeyToRawAddress,Z as serializeSignDoc};

