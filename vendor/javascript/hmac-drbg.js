import t from"hash.js";import e from"minimalistic-crypto-utils";import i from"minimalistic-assert";var s={};var r=t;var h=e;var n=i;function HmacDRBG(t){if(!(this instanceof HmacDRBG))return new HmacDRBG(t);this.hash=t.hash;this.predResist=!!t.predResist;this.outLen=this.hash.outSize;this.minEntropy=t.minEntropy||this.hash.hmacStrength;this._reseed=null;this.reseedInterval=null;this.K=null;this.V=null;var e=h.toArray(t.entropy,t.entropyEnc||"hex");var i=h.toArray(t.nonce,t.nonceEnc||"hex");var s=h.toArray(t.pers,t.persEnc||"hex");n(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits");this._init(e,i,s)}s=HmacDRBG;HmacDRBG.prototype._init=function init(t,e,i){var s=t.concat(e).concat(i);this.K=new Array(this.outLen/8);this.V=new Array(this.outLen/8);for(var r=0;r<this.V.length;r++){this.K[r]=0;this.V[r]=1}this._update(s);this._reseed=1;this.reseedInterval=281474976710656};HmacDRBG.prototype._hmac=function hmac(){return new r.hmac(this.hash,this.K)};HmacDRBG.prototype._update=function update(t){var e=this._hmac().update(this.V).update([0]);t&&(e=e.update(t));this.K=e.digest();this.V=this._hmac().update(this.V).digest();if(t){this.K=this._hmac().update(this.V).update([1]).update(t).digest();this.V=this._hmac().update(this.V).digest()}};HmacDRBG.prototype.reseed=function reseed(t,e,i,s){if("string"!==typeof e){s=i;i=e;e=null}t=h.toArray(t,e);i=h.toArray(i,s);n(t.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits");this._update(t.concat(i||[]));this._reseed=1};HmacDRBG.prototype.generate=function generate(t,e,i,s){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");if("string"!==typeof e){s=i;i=e;e=null}if(i){i=h.toArray(i,s||"hex");this._update(i)}var r=[];while(r.length<t){this.V=this._hmac().update(this.V).digest();r=r.concat(this.V)}var n=r.slice(0,t);this._update(i);this._reseed++;return h.encode(n,e)};var a=s;export default a;

