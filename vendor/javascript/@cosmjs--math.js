import t from"./decimal.js";import*as r from"bn.js";var e="default"in r?r.default:r;var n={};var i=n&&n.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(n,"__esModule",{value:true});n.Uint64=n.Uint53=n.Int53=n.Uint32=void 0;const o=i(e);const a=new o.default("18446744073709551615",10,"be");class Uint32$1{constructor(t){if(Number.isNaN(t))throw new Error("Input is not a number");if(!Number.isInteger(t))throw new Error("Input is not an integer");if(t<0||t>4294967295)throw new Error("Input not in uint32 range: "+t.toString());this.data=t}
/** @deprecated use Uint32.fromBytes */static fromBigEndianBytes(t){return Uint32$1.fromBytes(t)}
/**
   * Creates a Uint32 from a fixed length byte array.
   *
   * @param bytes a list of exactly 4 bytes
   * @param endianess defaults to big endian
   */static fromBytes(t,r="be"){if(4!==t.length)throw new Error("Invalid input length. Expected 4 bytes.");for(let r=0;r<t.length;++r)if(!Number.isInteger(t[r])||t[r]>255||t[r]<0)throw new Error("Invalid value in byte. Found: "+t[r]);const e="be"===r?t:Array.from(t).reverse();return new Uint32$1(e[0]*2**24+65536*e[1]+256*e[2]+e[3])}static fromString(t){if(!t.match(/^[0-9]+$/))throw new Error("Invalid string format");return new Uint32$1(Number.parseInt(t,10))}toBytesBigEndian(){return new Uint8Array([255&Math.floor(this.data/2**24),255&Math.floor(this.data/65536),255&Math.floor(this.data/256),255&Math.floor(this.data/1)])}toBytesLittleEndian(){return new Uint8Array([255&Math.floor(this.data/1),255&Math.floor(this.data/256),255&Math.floor(this.data/65536),255&Math.floor(this.data/2**24)])}toNumber(){return this.data}toString(){return this.data.toString()}}n.Uint32=Uint32$1;class Int53$1{constructor(t){if(Number.isNaN(t))throw new Error("Input is not a number");if(!Number.isInteger(t))throw new Error("Input is not an integer");if(t<Number.MIN_SAFE_INTEGER||t>Number.MAX_SAFE_INTEGER)throw new Error("Input not in int53 range: "+t.toString());this.data=t}static fromString(t){if(!t.match(/^-?[0-9]+$/))throw new Error("Invalid string format");return new Int53$1(Number.parseInt(t,10))}toNumber(){return this.data}toString(){return this.data.toString()}}n.Int53=Int53$1;class Uint53$1{constructor(t){const r=new Int53$1(t);if(r.toNumber()<0)throw new Error("Input is negative");this.data=r}static fromString(t){const r=Int53$1.fromString(t);return new Uint53$1(r.toNumber())}toNumber(){return this.data.toNumber()}toString(){return this.data.toString()}}n.Uint53=Uint53$1;class Uint64$1{constructor(t){if(t.isNeg())throw new Error("Input is negative");if(t.gt(a))throw new Error("Input exceeds uint64 range");this.data=t}
/** @deprecated use Uint64.fromBytes */static fromBytesBigEndian(t){return Uint64$1.fromBytes(t)}
/**
   * Creates a Uint64 from a fixed length byte array.
   *
   * @param bytes a list of exactly 8 bytes
   * @param endianess defaults to big endian
   */static fromBytes(t,r="be"){if(8!==t.length)throw new Error("Invalid input length. Expected 8 bytes.");for(let r=0;r<t.length;++r)if(!Number.isInteger(t[r])||t[r]>255||t[r]<0)throw new Error("Invalid value in byte. Found: "+t[r]);const e="be"===r?Array.from(t):Array.from(t).reverse();return new Uint64$1(new o.default(e))}static fromString(t){if(!t.match(/^[0-9]+$/))throw new Error("Invalid string format");return new Uint64$1(new o.default(t,10,"be"))}static fromNumber(t){if(Number.isNaN(t))throw new Error("Input is not a number");if(!Number.isInteger(t))throw new Error("Input is not an integer");let r;try{r=new o.default(t)}catch(t){throw new Error("Input is not a safe integer")}return new Uint64$1(r)}toBytesBigEndian(){return Uint8Array.from(this.data.toArray("be",8))}toBytesLittleEndian(){return Uint8Array.from(this.data.toArray("le",8))}toString(){return this.data.toString(10)}toNumber(){return this.data.toNumber()}}n.Uint64=Uint64$1;var u={};Object.defineProperty(u,"__esModule",{value:true});u.Uint64=u.Uint53=u.Uint32=u.Int53=u.Decimal=void 0;var s=t;Object.defineProperty(u,"Decimal",{enumerable:true,get:function(){return s.Decimal}});var f=n;Object.defineProperty(u,"Int53",{enumerable:true,get:function(){return f.Int53}});Object.defineProperty(u,"Uint32",{enumerable:true,get:function(){return f.Uint32}});Object.defineProperty(u,"Uint53",{enumerable:true,get:function(){return f.Uint53}});Object.defineProperty(u,"Uint64",{enumerable:true,get:function(){return f.Uint64}});const d=u.__esModule,m=u.Uint64,h=u.Uint53,l=u.Uint32,c=u.Int53,w=u.Decimal;export{w as Decimal,c as Int53,l as Uint32,h as Uint53,m as Uint64,d as __esModule,u as default};

