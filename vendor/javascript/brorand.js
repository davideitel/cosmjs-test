import t from"crypto";var n="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof self?self:global;var r={};var e;r=function rand(t){e||(e=new Rand(null));return e.generate(t)};function Rand(t){(this||n).rand=t}r.Rand=Rand;Rand.prototype.generate=function generate(t){return this._rand(t)};Rand.prototype._rand=function _rand(t){if((this||n).rand.getBytes)return(this||n).rand.getBytes(t);var r=new Uint8Array(t);for(var e=0;e<r.length;e++)r[e]=(this||n).rand.getByte();return r};if("object"===typeof self)self.crypto&&self.crypto.getRandomValues?Rand.prototype._rand=function _rand(t){var n=new Uint8Array(t);self.crypto.getRandomValues(n);return n}:self.msCrypto&&self.msCrypto.getRandomValues?Rand.prototype._rand=function _rand(t){var n=new Uint8Array(t);self.msCrypto.getRandomValues(n);return n}:"object"===typeof window&&(Rand.prototype._rand=function(){throw new Error("Not implemented yet")});else try{var a=t;if("function"!==typeof a.randomBytes)throw new Error("Not supported");Rand.prototype._rand=function _rand(t){return a.randomBytes(t)}}catch(t){}var o=r;const d=r.Rand;export default o;export{d as Rand};

